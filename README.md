# go-api-boot
![Coverage](https://img.shields.io/badge/Coverage-44.8%25-yellow)
[![Go Report Card](https://goreportcard.com/badge/github.com/SaiNageswarS/go-api-boot)](https://goreportcard.com/report/github.com/SaiNageswarS/go-api-boot) [![Go Reference](https://pkg.go.dev/badge/github.com/SaiNageswarS/go-api-boot.svg)](https://pkg.go.dev/github.com/SaiNageswarS/go-api-boot)


> **Batteriesâ€‘included framework for building productionâ€‘grade gRPC + HTTP APIs in Go â€“ with generics, MongoDB ODM, cloud utilities, zeroâ€‘config HTTPS, workers, and a oneâ€‘line bootstrap CLI.**

---

## ğŸ“‘ Table of Contents

1. [Overview](#overview)
2. [Why goâ€‘apiâ€‘boot?](#why-go-api-boot)
3. [Key Features](#key-features)
4. [QuickÂ Start](#quick-start)

   1. [Bootstrap a New Service](#bootstrap-a-new-service)
   2. [Running Locally](#running-locally)
5. [ProjectÂ Structure](#project-structure)
6. [CoreÂ Modules](#core-modules)

   * [Server](#server)
   * [ODM (MongoDB)](#odm-mongodb)
   * [AuthÂ &Â JWT](#auth--jwt)
   * [Cloud Abstractions](#cloud-abstractions)
   * [Zeroâ€‘Config SSL/TLS](#zero-config-ssltls)
7. [CLI Reference](#cli-reference)
8. [Examples](#examples)
9. [Contributing](#contributing)
10. [License](#license)

---

## Overview

**goâ€‘apiâ€‘boot** eliminates the repetitive plumbing required to ship modern API services in Go.  With a single CLI command you get:

* A fully wired **gRPC** server that also serves **gRPCâ€‘Web** and **REST** gateways â€“ no Envoy sidecars or extra proxies.
* MongoDB repositories implemented with **GoÂ 1.22 generics**.
* Opinionated middlewares (JWT auth, logging, panic recovery) that you can opt out of perâ€‘method.
* A relocatable **cloud toolkit** (AWS / Azure / GCP) for signed URLs, blob storage, secret resolution, etc.  
* **Zero-configuration HTTPS** â€“ serve valid TLS certificates on day 0. 
* Dependency injection wiring generated by **GoogleÂ Wire** â€“ never handâ€‘edit `wire.go` again.

The result: you write business logic, not boilerplate.

---

## Why goâ€‘apiâ€‘boot?

| Challenge                                               | Typical Effort          | **With goâ€‘apiâ€‘boot**                    |
| ------------------------------------------------------- | ----------------------- | --------------------------------------- |
| Spin up gRPC+gRPCâ€‘Web server, CORS, healthz, Prometheus | Days                    | `go-api-boot bootstrap â€¦` â€“ seconds     |
| MongoDB CRUD layer with generics & tests                | Days                    | `go-api-boot repository User` â€“ seconds |
| Secure service with JWT, skip for selected methods      | Manual interceptors     | Builtâ€‘in + `AuthFuncOverride`           |
| Signed S3 / Blob URLs                                   | SDK boilerplate         | Oneâ€‘liner via `cloud.Cloud` interface   |
| Automatic HTTPS certificates with a shared cloud cache                            | External infrastructure | `server.WithSSL(true)` + `SslCloudCache` â€“ seconds                  |

---

## Key Features

* **Firstâ€‘classÂ gRPC & gRPCâ€‘Web** â€“ serve browsers natively without Envoy.
* **Generic ODM for MongoDB** â€“ typeâ€‘safe repos (`BootRepository[T]`) with async helpers.
* **JWT Auth & Middleware Stack** â€“ observability, logging, panic recovery preâ€‘wired.
* **Cloud Providers** â€“ interchangeable AWS / Azure / GCP helpers for storage & secrets.
* **Zeroâ€‘Config SSL** â€“ automatic Letâ€™sÂ Encrypt certificates with exponential backâ€‘off and optional cloud-backed cache (SslCloudCache) for stateless containers.
* **Wireâ€‘powered DI** â€“ codeâ€‘generated providers for services, repos, config.
* **Bootstrap CLI** â€“ scaffold full service, models, repos, services, Dockerfile, build scripts.

---

## QuickÂ Start

### Bootstrap a New Service

```bash
# Install the CLI once
$ go install github.com/SaiNageswarS/go-api-boot/cmd/go-api-boot@latest

# Scaffold a new service in ./quizService
$ go-api-boot bootstrap github.com/yourname/quizService proto
```

Generated layout â¤µï¸

```
quizService/
â”œâ”€â”€ cmd/...
â”œâ”€â”€ db/              # repositories
â”œâ”€â”€ generated/       # proto stubs (via build script)
â”œâ”€â”€ services/        # business logic
â”œâ”€â”€ Dockerfile       # multistage build
â””â”€â”€ wire.go          # dependency injection (generated)
```

### Running Locally

```bash
# Generate proto code & build binary
$ ./build.sh

# Export secrets (or use .env / Azure Key Vault)
$ export MONGO_URI=mongodb://localhost:27017
$ export ACCESS_SECRET=supersecret
$ export DOMAIN=api.example.com       # required for SSL
# (optional) use cloud cache for certs
$ export SSL_BUCKET=my-cert-bucket    # bucket / container name

# Start the server â€“ gRPC :50051, HTTP :8081 (HTTPS if --ssl)
$ ./build/quizService
```

---

## ProjectÂ Structure

| Path         | Purpose                                               |
| ------------ | ----------------------------------------------------- |
| `db/`        | Generic MongoDB models & repos                        |
| `services/`  | Stateless business services (one per proto service)   |
| `generated/` | `.pb.go` & `.pb.gw.go` generated by the build script  |
| `wire.go`    | GoogleÂ Wire injector (autoâ€‘generated)                 |
| `server/`    | Core server package (CORS, gRPCâ€‘Web, SSL, metrics, â€¦) |
| `cloud/`     | Cloud provider abstractions (aws/azure/gcp)           |

---

## CoreÂ Modules

### Server

```go
// Pick a cloud provider â€“ all implement cloud.Cloud
cloudFns := cloud.NewAWS() // or NewAzure(), NewGCP()

boot := server.NewGoApiBoot(
    server.WithCorsConfig(cors.AllowAll()),
    server.AppendUnaryInterceptors(app.UnaryInterceptors),
    server.WithSSL(true),          // HTTPS via Letâ€™sÂ Encrypt
    server.WithCloudCache(cloudFns), // <â€” stores certs in S3 / Blob / GCS
)
boot.Start(":50051", ":8081")
```

* gRPC, gRPCâ€‘Web, and optional REST gateway on the same port.
* Middleware registry (unary + stream) to plug in OpenTelemetry, Prometheus, etc.

### ODM (MongoDB)

```go
// Model
type Profile struct {
    ID    string `bson:"_id"`
    Name  string `bson:"name"`
}
func (p *Profile) Id() string { return p.ID }

// Repository â€“ generated with CLI
type ProfileRepository struct {
    odm.UnimplementedBootRepository[Profile]
}
var _ ProfileRepoInterface = (*ProfileRepository)(nil)

// Provide via Wire
func ProvideProfileRepo() ProfileRepoInterface {
    return &ProfileRepository{
        odm.NewUnimplementedBootRepository[Profile](
            odm.WithDatabase("authGo"),
            odm.WithCollectionName("profiles"),
        ),
    }
}
```

Async helpers return `<-chan T` + `<-chan error` for fanâ€‘out concurrency.

### AuthÂ &Â JWT

* HS256 by default â€“ override via envÂ vars or secrets manager.
* Skip auth perâ€‘method:

```go
func (s *LoginService) AuthFuncOverride(ctx context.Context, method string) (context.Context, error) {
    return ctx, nil // public endpoint
}
```

### Cloud Abstractions

```go
var cloudFns cloud.Cloud = cloud.NewAWS()
url, download := cloudFns.GetPresignedUrl(bucket, key, 15*time.Minute)
```

Switch provider with one line â€“ signatures stay identical.

### Zeroâ€‘Config SSL/TLS

There are two ways to persist the Letâ€™s Encrypt certificates:

1. **Local** autocert.DirCache("certs") â€“ good for single-node dev / on-prem.
2. **Distributed cache with** SslCloudCache â€“ perfect for Docker / Kubernetes where the container filesystem is ephemeral.

```go
import (
    "github.com/SaiNageswarS/go-api-boot/cloud"
    "github.com/SaiNageswarS/go-api-boot/server"
)

func main() {
    os.Setenv("DOMAIN", "api.example.com")  // required
    os.Setenv("SSL_BUCKET", "my-cert-bucket") // for SslCloudCache

    cloudFns := cloud.NewAWS()              // swap for Azure / GCP

    boot := server.NewGoApiBoot(
        server.WithSSL(true),
        server.WithCloudCache(cloudFns),    // enable SslCloudCache
    )
    boot.Start(":50051", ":8081")           // :8081 will be HTTPS
}
```

* ACME challenge handled internally, exponential backâ€‘off for cloud IP propagation.
* Just expose portÂ 80 and 443 in your container spec.
* SslCloudCache streams certificates to the chosen object store (S3, Azure Blob, GCS).
* Multiple replicas of your service instantly share the same certs â€“ no race conditions, no volume mounts.
* Exponential back-off is applied automatically while waiting for DNS / IP propagation.

---

## CLI Reference

| Command                             | Description                          |
| ----------------------------------- | ------------------------------------ |
| `bootstrap <modulePath> <protoDir>` | Scaffold a new project               |
| `repository <ModelName>`            | Generate model + repository in `db/` |
| `service <ServiceName>`             | Generate skeleton gRPC service       |
| `worker <JobName>`                  | Generate scheduled job template      |

Run with `-h` for full flags.

---

## Examples

* **Kotlang/authGo** â€“ realâ€‘world auth service built with goâ€‘apiâ€‘boot â†’ [https://github.com/Kotlang/authGo](https://github.com/Kotlang/authGo)

---

## Contributing

PRs and issues are welcome!

1. Fork â¡ï¸ hack â¡ï¸ PR.
2. Run `make test lint` â€“ zero lint errors.
3. Add unit / integration tests for new features.

---

## License

Apacheâ€‘2.0 â€“ see [https://github.com/SaiNageswarS/go-api-boot/blob/master/LICENSE](LICENSE) for details.
